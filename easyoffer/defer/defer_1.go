package main

import "fmt"

/*

Что делает defer x.S():
1) Сразу вычисляет получатель (receiver) x

2) Создается "замыкание" с текущим значением x

3) Но так как S() имеет pointer receiver (x *X), то передается указатель на x

4) Метод выполняется при выходе из функции

// x.V = 123
// запоминает &x (адрес x)
// меняет значение по адресу &x
// функция завершается
// выполняется defer: x.S() → печатает x.V = 456

Если бы ресивер у S был не указатель, то напечаталось бы 123
*/

type X struct {
	V int
}

func (x *X) S() {
	fmt.Println(x.V) // 456
}
func main() {
	x := X{123}
	defer x.S()
	x.V = 456
}
