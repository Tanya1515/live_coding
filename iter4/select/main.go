package main

import (
	"fmt"
	"time"
)

func main() {
	ch := make(chan int)

	go func() {
		time.Sleep(1 * time.Second)

		ch <- 42

		close(ch)
	}()

	for {
		select {
		case val, ok := <-ch:
			if !ok {
				fmt.Println("Channel closed")

				return
			}

			fmt.Println(val)

		default:
			fmt.Println("No value yet")

			time.Sleep(200 * time.Millisecond)
		}
	}
}

// 
// Шаги исполнения программы: 
// 1) Создаем небуферизованыый канал 
// 2) Запускаем горутину: 
// 		а) Горутина заснет на 1 секунду 
// 		б) В канал будет записано число 42 (на этом этапе будет блокировка, поскольку канал небуферизованный) 
// 		в) Закрытие канала
// 3) В main-горутине выполняется бесконечный цикл с select: 
// 		а) В силу того, что горутина уснула на 1 секунду 5 раз выполнится вывод в консоль "No value yet" 
//		б) Сначала прочитается значение из канала и напечатается в консоль: 42 
// 		в) Затем прочитается из закрытого канала ZeroValue-значение для int: 0, а в ok записано false 
// 		г) Будет напечатано в консоль "Channel closed" и main-горутина завершит свое исполнение. 



// !!!! Проверила запуском программы: немного ошиблась !!!

//  - поскольку запись в канал и его последующее 
// закрытие не атомарные операции - то периодически после печати числа 42 в консоль может проскакивать 
// "No value yet", поскольку горутина может не успеть закрыть канал, в силу чего main-горутина 
// свалиться в default 