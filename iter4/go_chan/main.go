package main

import (
	"fmt"
	"sync"
)

func main() {
	ch := make(chan int, 1)

	var wg sync.WaitGroup

	wg.Add(2)

	go func() {
		defer wg.Done()
		ch <- 42
		close(ch)
	}()

	go func() {
		defer wg.Done()
		val := <-ch
		fmt.Println(val)
	}()

	wg.Wait()
}

// Шаги исполнения программы: 
// 1) Создание буферизованного канала и WaitGroup 
// 2) Добавление числа 2 в WaitGroup 
// 3) Запуск 1ой горутины: 
// 		a) запись в канал числа 42 (блокировки не будет, поскольку канал буферизованный)
// 		б) закрытие канала 
// 		с) выполнение wg.Done() 
// 4) Асинхронно с 1ой горутиной будет запущена 2ая горутина 
// 		а) попытка считать значение из буферизованного канала (будет блокировка, пока не появится значение в канале) 
// 		б) как только считали значение - выводим в консоль: печатаем в консоль 42 
// 		с) выполняем wg.Done() 
// 5) в main-горутине будет выполняться ожидание завершения двух горутин.


